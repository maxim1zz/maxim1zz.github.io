{
  "version": 3,
  "sources": ["../../get-mp3-duration/index.js"],
  "sourcesContent": ["'use strict'\n\nconst versions = [ '2.5', 'x', '2', '1' ]\nconst layers = [ 'x', '3', '2', '1' ]\nconst bitRates = {\n  'V1Lx': [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n  'V1L1': [ 0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448 ],\n  'V1L2': [ 0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384 ],\n  'V1L3': [ 0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320 ],\n  'V2Lx': [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n  'V2L1': [ 0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256 ],\n  'V2L2': [ 0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160 ],\n  'V2L3': [ 0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160 ],\n  'VxLx': [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n  'VxL1': [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n  'VxL2': [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n  'VxL3': [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\n}\nconst sampleRates = {\n  'x': [ 0, 0, 0 ],\n  '1': [ 44100, 48000, 32000 ],\n  '2': [ 22050, 24000, 16000 ],\n  '2.5': [ 11025, 12000, 8000 ]\n}\n\nconst samples = {\n  x: {\n    x: 0,\n    1: 0,\n    2: 0,\n    3: 0\n  },\n  1: { // MPEGv1,    Layers 1, 2, 3\n    x: 0,\n    1: 384,\n    2: 1152,\n    3: 1152\n  },\n  2: { // MPEGv2/2.5, Layers 1, 2, 3\n    x: 0,\n    1: 384,\n    2: 1152,\n    3: 576\n  }\n}\n\nmodule.exports = (buffer) => {\n  const scratch = Buffer.alloc(100)\n  const bytesRead = buffer.copy(scratch, 0, 0, 100)\n  if (bytesRead < 100) return 0\n\n  let offset = skipID3(scratch)\n  let duration = 0\n\n  while (offset < buffer.length) {\n    const bytesRead = buffer.copy(scratch, 0, offset, offset + 10)\n    if (bytesRead < 10) return round(duration)\n\n    // looking for 1111 1111 111 (frame synchronization bits)\n    if (scratch[0] === 0xff && (scratch[1] & 0xe0) === 0xe0) {\n      const header = parseFrameHeader(scratch)\n\n      if (header.frameSize && header.samples) {\n        offset += header.frameSize\n        duration += (header.samples / header.sampleRate)\n      } else {\n        offset++ // corrupt file?\n      }\n    } else if (scratch[0] === 0x54 && scratch[1] === 0x41 && scratch[2] === 0x47) { // TAG\n      offset += 128 // skip over id3v1 tag size\n    } else {\n      offset++ // corrupt file?\n    }\n  }\n\n  return round(duration)\n}\n\nfunction skipID3 (buffer) {\n  // http://id3.org/d3v2.3.0\n  if (buffer[0] === 0x49 && buffer[1] === 0x44 && buffer[2] === 0x33) { // ID3\n    const id3v2Flags = buffer[5]\n    const footerSize = (id3v2Flags & 0x10) ? 10 : 0\n\n    // ID3 size encoding is crazy (7 bits in each of 4 bytes)\n    const z0 = buffer[6]\n    const z1 = buffer[7]\n    const z2 = buffer[8]\n    const z3 = buffer[9]\n\n    if (((z0 & 0x80) === 0) && ((z1 & 0x80) === 0) && ((z2 & 0x80) === 0) && ((z3 & 0x80) === 0)) {\n      const tagSize = ((z0 & 0x7f) * 2097152) + ((z1 & 0x7f) * 16384) + ((z2 & 0x7f) * 128) + (z3 & 0x7f)\n      return 10 + tagSize + footerSize\n    }\n  }\n\n  return 0\n}\n\nfunction frameSize (samples, layer, bitRate, sampleRate, paddingBit) {\n  if (layer === 1) {\n    return (((samples * bitRate * 125 / sampleRate) + paddingBit * 4)) | 0\n  } else { // layer 2, 3\n    return (((samples * bitRate * 125) / sampleRate) + paddingBit) | 0\n  }\n}\n\nfunction parseFrameHeader (header) {\n  const b1 = header[1]\n  const b2 = header[2]\n\n  const versionBits = (b1 & 0x18) >> 3\n  const version = versions[versionBits]\n  const simpleVersion = (version === '2.5' ? 2 : version)\n\n  const layerBits = (b1 & 0x06) >> 1\n  const layer = layers[layerBits]\n\n  const bitRateKey = 'V' + simpleVersion + 'L' + layer\n  const bitRateIndex = (b2 & 0xf0) >> 4\n  const bitRate = bitRates[bitRateKey][bitRateIndex] || 0\n\n  const sampleRateIdx = (b2 & 0x0c) >> 2\n  const sampleRate = sampleRates[version][sampleRateIdx] || 0\n\n  const sample = samples[simpleVersion][layer]\n\n  const paddingBit = (b2 & 0x02) >> 1\n\n  return {\n    bitRate: bitRate,\n    sampleRate: sampleRate,\n    frameSize: frameSize(sample, layer, bitRate, sampleRate, paddingBit),\n    samples: sample\n  }\n}\n\nfunction round (duration) {\n  return Math.round(duration * 1000) // round to nearest ms\n}\n"],
  "mappings": "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",
  "names": ["bytesRead", "samples"]
}
